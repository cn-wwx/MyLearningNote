# 一 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗



## 为什么需要复杂度分析

1、测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响。

2、测试结果受数据规模的影响很大

对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快。



## 大O复杂度表示法

所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比

![image-20220610102905081](数据结构与算法.assets/image-20220610102905081.png)

T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度

当 n 很大时，可以把它想象成 10000、100000。而公式中的**低阶、常量、系数**三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如T(n) = O(n)； T(n) = O(n2)



### 时间复杂度分析

1、只关注循环执行次数最多的一段代码

2、加法法则：总复杂度等于量级最大的那段代码的复杂度

3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积



#### 几种常见时间复杂度实例分析

![image-20220610103601102](数据结构与算法.assets/image-20220610103601102.png)

1、O(logn)、O(nlogn)

```java

 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。变量 i 的取值就是一个等比数列

![image-20220610104244315](数据结构与算法.assets/image-20220610104244315.png)

通过 2x=n 求解 x 这个问题，x=log2n，所以，这段代码的时间复杂度就是 O(log2n)



2、O(m+n)、O(m*n)

代码的复杂度由两个数据的规模来决定

```java

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

### 空间复杂度分析

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系



# 二 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

## 最好、最坏情况时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度

```java

// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

## 平均情况时间复杂度

要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值

![image-20220610105244467](数据结构与算法.assets/image-20220610105244467.png)

要查找的变量 x，要么在数组里，要么就不在数组里。假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)

把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样

![image-20220610105529531](数据结构与算法.assets/image-20220610105529531.png)





# 三 贪心算法

经典应用：霍夫曼编码、Prim和Kruskal最小生成树算法、Dijkstra单源最短路径算法



## 如何理解“贪心算法”

- 当看到这类问题时，首先联想导贪心算法：针对一组数据，定义了限制值和期望值，在满足限制值的情况下，期望值最大
- 尝试是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据
- 举几个例子看下贪心算法产生的结果是否是最优的



## 贪心算法实战分析



### 分糖果



### 钱币找零



### 区间覆盖



### 霍夫曼编码

- 文本中有多少个字符，以及每个字符出现的频率，根据频率的不同，选择不同长度的编码，通过用不等长的编码方法，进一步压缩
- 由于编码是不等长得，为了避免解压缩过程中的歧义，各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况

编码过程：

把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。

![image-20220617103913444](数据结构与算法.assets/image-20220617103913444.png)

![image-20220617103919608](数据结构与算法.assets/image-20220617103919608.png)





# 四 分治算法

分治算法（divide and conquer）的核心思想其实就是四个字，**分而治之** ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解



分治算法一般步骤：

- 分解
- 解决
- 合并





## 应用分析

1、求出一组数据的有序对个数或逆序对个数

```java

private int num = 0; // 全局变量或者成员变量

public int count(int[] a, int n) {
  num = 0;
  mergeSortCounting(a, 0, n-1);
  return num;
}

private void mergeSortCounting(int[] a, int p, int r) {
  if (p >= r) return;
  int q = (p+r)/2;
  mergeSortCounting(a, p, q);
  mergeSortCounting(a, q+1, r);
  merge(a, p, q, r);
}

private void merge(int[] a, int p, int q, int r) {
  int i = p, j = q+1, k = 0;
  int[] tmp = new int[r-p+1];
  while (i<=q && j<=r) {
    if (a[i] <= a[j]) {
      tmp[k++] = a[i++];
    } else {
      num += (q-i+1); // 统计p-q之间，比a[j]大的元素个数
      tmp[k++] = a[j++];
    }
  }
  while (i <= q) { // 处理剩下的
    tmp[k++] = a[i++];
  }
  while (j <= r) { // 处理剩下的
    tmp[k++] = a[j++];
  }
  for (i = 0; i <= r-p; ++i) { // 从tmp拷贝回a
    a[p+i] = tmp[i];
  }
}
```



2、二维平面上有n个点，如何快速计算出两个距离最近的点对



3、有两个 n×n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？



4、leetcode：生成括号、合并k个有序链表



5、在海量数据处理中的应用

比如，给 10GB 的订单文件按照金额排序这样一个需求。

要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。



## 小结

采用分治思想的算法包括： 

1.快速排序算法 

2.合并排序算法 

3.桶排序算法 

4.基数排序算法 

5.二分查找算法 

6.利用递归树求解算法复杂度的思想 

7.分布式数据库利用分片技术做数据处理 

8.MapReduce模型处理思想



应用场景：人口普查、公司管理



# 五 回溯算法

本质：

- 枚举；
- 大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解；
- 回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。

经典题型：数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列、正则表达式.......





# 六 图

## 链表、树、图的关系

链表是特殊化的树（斜树）

树是特殊化的图

- N个点N-1条边的连通无向图——树
- N个点N条边的连通无向图——基环树



## 图的存储与遍历

邻接矩阵、邻接表
BFS、DFS

```java
//邻接表的代码
/**
 * @author WWX
 * 无向图
 * @date 2022/06/16 14:50
 **/
public class myGraph {
    private int v;//顶点个数
    private LinkedList<Integer> adj[]; //邻接表

    public myGraph(int v) {
        this.v = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; ++i) {
            adj[i] = new LinkedList<>();
        }
    }

    public void addEdge(int s, int t) {
        adj[s].add(t);
        adj[t].add(s);
    }

    public void bfs(int s, int t) {
        if (s == t) {
            return;
        }
        //记录已经被访问的顶点，用来避免顶点被重复访问
        boolean [] visited = new boolean[v];
        visited[s] = true;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(s);
        //记录搜索路径
        int [] prev = new int[v];
        Arrays.fill(prev, -1);
        while (!queue.isEmpty()) {
            int w = queue.poll();
            //遍历和w节点相连的节点
            for (int i = 0; i < adj[w].size(); i++) {
                //访问节点
                int q = adj[w].get(i);
                if (!visited[q]) {
                    prev[q] = w;
                    if (q == t) {
                        print(prev, s, t);
                        return;
                    }
                    visited[q] = true;
                    queue.add(q);
                }
            }
        }
    }

    private void print(int [] prev, int s, int t) {
        //递归打印s->t的路径
        if (prev[t] != -1 && t != s) {
            print(prev, s, prev[t]);
        }
        System.out.println(t + " ");
    }

    boolean found = false;

    public void dfs(int s, int t) {
        found = false;
        boolean [] visited = new boolean[v];
        int [] prev = new int[v];
        Arrays.fill(prev, -1);
        recurDfs(s, t, visited, prev);
        print(prev, s, t);
    }

    private void recurDfs(int w, int t, boolean [] visited, int [] prev) {
        if (found == true) {
            return;
        }
        visited[w] = true;
        if (w == t) {
            found = true;
            return;
        }
        for (int i = 0; i < adj[w].size(); i++) {
            int q = adj[w].get(i);
            prev[q] = w;
            recurDfs(w, t, visited, prev);
        }
    }
}

```



## 实战

1、课程表



2、课程表Ⅱ



3、冗余连接



4、冗余连接Ⅱ



# 七 DFS & BFS

- 归纳总结状态、状态空间和把问题抽象为树或图的方法
- 搜索是解决一切问题的万金油算法
- 学会自定义搜索框架，更好的帮助学习DP和图论算法
- 搜索题最能训练代码能力



## 状态与状态空间



## DFS实现与应用



## BFS实现与应用



## DFS和BFS对比



