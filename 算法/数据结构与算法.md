# 一 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗



## 为什么需要复杂度分析

1、测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响。

2、测试结果受数据规模的影响很大

对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快。



## 大O复杂度表示法

所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比

![image-20220610102905081](数据结构与算法.assets/image-20220610102905081.png)

T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度

当 n 很大时，可以把它想象成 10000、100000。而公式中的**低阶、常量、系数**三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如T(n) = O(n)； T(n) = O(n2)



### 时间复杂度分析

1、只关注循环执行次数最多的一段代码

2、加法法则：总复杂度等于量级最大的那段代码的复杂度

3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积



#### 几种常见时间复杂度实例分析

![image-20220610103601102](数据结构与算法.assets/image-20220610103601102.png)

1、O(logn)、O(nlogn)

```java

 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。变量 i 的取值就是一个等比数列

![image-20220610104244315](数据结构与算法.assets/image-20220610104244315.png)

通过 2x=n 求解 x 这个问题，x=log2n，所以，这段代码的时间复杂度就是 O(log2n)



2、O(m+n)、O(m*n)

代码的复杂度由两个数据的规模来决定

```java

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

### 空间复杂度分析

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系



# 二 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

## 最好、最坏情况时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度

```java

// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

## 平均情况时间复杂度

要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值

![image-20220610105244467](数据结构与算法.assets/image-20220610105244467.png)

要查找的变量 x，要么在数组里，要么就不在数组里。假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)

把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样

![image-20220610105529531](数据结构与算法.assets/image-20220610105529531.png)





# 三 贪心算法

经典应用：霍夫曼编码、Prim和Kruskal最小生成树算法、Dijkstra单源最短路径算法



## 如何理解“贪心算法”

- 当看到这类问题时，首先联想导贪心算法：针对一组数据，定义了限制值和期望值，在满足限制值的情况下，期望值最大
- 尝试是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据
- 举几个例子看下贪心算法产生的结果是否是最优的



## 贪心算法实战分析



### 分糖果



### 钱币找零



### 区间覆盖



### 霍夫曼编码

- 文本中有多少个字符，以及每个字符出现的频率，根据频率的不同，选择不同长度的编码，通过用不等长的编码方法，进一步压缩
- 由于编码是不等长得，为了避免解压缩过程中的歧义，各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况

编码过程：

把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。

![image-20220617103913444](数据结构与算法.assets/image-20220617103913444.png)

![image-20220617103919608](数据结构与算法.assets/image-20220617103919608.png)





# 四 分治算法

分治算法（divide and conquer）的核心思想其实就是四个字，**分而治之** ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解



分治算法一般步骤：

- 分解
- 解决
- 合并





## 应用分析

1、求出一组数据的有序对个数或逆序对个数

```java

private int num = 0; // 全局变量或者成员变量

public int count(int[] a, int n) {
  num = 0;
  mergeSortCounting(a, 0, n-1);
  return num;
}

private void mergeSortCounting(int[] a, int p, int r) {
  if (p >= r) return;
  int q = (p+r)/2;
  mergeSortCounting(a, p, q);
  mergeSortCounting(a, q+1, r);
  merge(a, p, q, r);
}

private void merge(int[] a, int p, int q, int r) {
  int i = p, j = q+1, k = 0;
  int[] tmp = new int[r-p+1];
  while (i<=q && j<=r) {
    if (a[i] <= a[j]) {
      tmp[k++] = a[i++];
    } else {
      num += (q-i+1); // 统计p-q之间，比a[j]大的元素个数
      tmp[k++] = a[j++];
    }
  }
  while (i <= q) { // 处理剩下的
    tmp[k++] = a[i++];
  }
  while (j <= r) { // 处理剩下的
    tmp[k++] = a[j++];
  }
  for (i = 0; i <= r-p; ++i) { // 从tmp拷贝回a
    a[p+i] = tmp[i];
  }
}
```



2、二维平面上有n个点，如何快速计算出两个距离最近的点对



3、有两个 n×n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？



4、leetcode：生成括号、合并k个有序链表



5、在海量数据处理中的应用

比如，给 10GB 的订单文件按照金额排序这样一个需求。

要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。



## 小结

采用分治思想的算法包括： 

1.快速排序算法 

2.合并排序算法 

3.桶排序算法 

4.基数排序算法 

5.二分查找算法 

6.利用递归树求解算法复杂度的思想 

7.分布式数据库利用分片技术做数据处理 

8.MapReduce模型处理思想



应用场景：人口普查、公司管理



# 五 回溯算法

本质：

- 枚举；
- 大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解；
- 回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。

经典题型：数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列、正则表达式.......





# 六 图

## 链表、树、图的关系

链表是特殊化的树（斜树）

树是特殊化的图

- N个点N-1条边的连通无向图——树
- N个点N条边的连通无向图——基环树



## 图的存储与遍历

邻接矩阵、邻接表
BFS、DFS

```java
//邻接表的代码
/**
 * @author WWX
 * 无向图
 * @date 2022/06/16 14:50
 **/
public class myGraph {
    private int v;//顶点个数
    private LinkedList<Integer> adj[]; //邻接表

    public myGraph(int v) {
        this.v = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; ++i) {
            adj[i] = new LinkedList<>();
        }
    }

    public void addEdge(int s, int t) {
        adj[s].add(t);
        adj[t].add(s);
    }

    public void bfs(int s, int t) {
        if (s == t) {
            return;
        }
        //记录已经被访问的顶点，用来避免顶点被重复访问
        boolean [] visited = new boolean[v];
        visited[s] = true;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(s);
        //记录搜索路径
        int [] prev = new int[v];
        Arrays.fill(prev, -1);
        while (!queue.isEmpty()) {
            int w = queue.poll();
            //遍历和w节点相连的节点
            for (int i = 0; i < adj[w].size(); i++) {
                //访问节点
                int q = adj[w].get(i);
                if (!visited[q]) {
                    prev[q] = w;
                    if (q == t) {
                        print(prev, s, t);
                        return;
                    }
                    visited[q] = true;
                    queue.add(q);
                }
            }
        }
    }

    private void print(int [] prev, int s, int t) {
        //递归打印s->t的路径
        if (prev[t] != -1 && t != s) {
            print(prev, s, prev[t]);
        }
        System.out.println(t + " ");
    }

    boolean found = false;

    public void dfs(int s, int t) {
        found = false;
        boolean [] visited = new boolean[v];
        int [] prev = new int[v];
        Arrays.fill(prev, -1);
        recurDfs(s, t, visited, prev);
        print(prev, s, t);
    }

    private void recurDfs(int w, int t, boolean [] visited, int [] prev) {
        if (found == true) {
            return;
        }
        visited[w] = true;
        if (w == t) {
            found = true;
            return;
        }
        for (int i = 0; i < adj[w].size(); i++) {
            int q = adj[w].get(i);
            prev[q] = w;
            recurDfs(w, t, visited, prev);
        }
    }
}

```



## 实战

1、课程表



2、课程表Ⅱ



3、冗余连接



4、冗余连接Ⅱ



# 七 DFS & BFS

- 归纳总结状态、状态空间和把问题抽象为树或图的方法
- 搜索是解决一切问题的万金油算法
- 学会自定义搜索框架，更好的帮助学习DP和图论算法
- 搜索题最能训练代码能力



## 状态与状态空间

### 状态

什么是状态，就是**程序维护的所有动态数据构成的集合**：

- 题目中涉及的数学信息
- 函数访问的所有变量
- 手动计算时关注的所有数据



### 状态空间

所有可能状态构成的**集合**就是一个问题的状态空间。

把状态看作一个点，如果一个状态可以到达另一个状态，两点之间可以连一条线。这样就把整个状态空间抽象成了**有向图**，对问题的求解就是对这张**图的遍历**。

如机票问题抽象成有向图，只不过整张图是一条链。

如子集问题抽象成有向图，整张图其实是一颗满二叉树（未剪枝）



## 搜索

搜索就是采用直接遍历整个状态空间的方式寻找答案的一类算法，根据遍历方式不同分为：

- 深度优先搜索
- 广度优先搜索

一般来说，每个状态只遍历一次，所以当状态空间是图而不是树时，需要判断重复（记忆化，在代码中体现为boolean [] visited)



搜索题的解题步骤：

- 提取信息
- 定义状态
- 确定遍历方法
- 定义搜索框架
  - 如果是DFS，状态作为参数，确定递归边界，注意还原现场（回溯）
  - 如果是BFS，状态需要用队列保存
  - 考虑是否要判重
- 编程



## 实战

1、电话号码字母组合



2、N皇后



3、岛屿数量



4、被围绕的区域

从边界开始搜索



5、最小基因变化

求最小步数，一般用BFS，层次序搜索，一层等于一步



6、矩阵中最长递增路径

DFS+记忆化搜索，定义一个缓存数组，缓存每一个单元格的最大路径数



## DFS和BFS对比

DFS更适合搜索树形状态空间

- 递归本身就会产生树状结构
- 可以用一个全局遍历来维护状态中较为复杂的信息（子集问题、排列问题）
- 不需要队列

BFS适合求“最小代价”、“最小步数”问题

- BFS按层次序搜索，第k步搜完才会去搜第k+1步



在状态空间为图时，DFS和BFS差不多





# 八、堆

堆是一种高效维护集合中最大或最小元素的数据结构。

堆是一颗二叉树，并且满足堆性质：

- 大根堆任意结点>=其所有子节点
- 小根堆任意节点<=其所有子节点



## 实现

### 二叉堆

一般用一个一维数组实现，利用完全二叉树的节点编号特性。常用操作：

- 建堆：O(N)
- 查询最值：O(1)
- 插入：O(logN)
- 取出最值：O(logN)



假设元素从1开始存储那么：

- 索引为p的节点的左孩子的下标为p*2
- 索引为p的节点的右孩子的下标为p*2 + 1
- 索引为p的节点的父节点下标为p/2（向下取整）

假设元素从0开始存储那么：

- 索引为p的节点的左孩子的下标为p*2 + 1
- 索引为p的节点的右孩子的下标为p*2 + 2
- 索引为p的节点的父节点下标为(p-1)/2（向下取整）

代码：

```java
//大顶堆
public class myHeap {
    private int [] a; //数组，下标从1开始
    private int n; //堆可以存储的最大数据个数
    private int count; //堆中已经存储的数据个数

    public myHeap(int capacity) {
        this.a = new int[capacity + 1];
        this.n = capacity;
        this.count = 0;
    }
	
    public void insert(int data) {
        if (count >= n) {
            return;
        }
        ++count;
        a[count] = data;
        int i = count;
        //自底向上
        while (i / 2 > 0 && a[i] > a[i / 2]) {
            swap(a, i, i / 2);
            i = i / 2;
        }
    }

    public void swap(int [] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    //堆尾放到堆顶，然后堆化
    public void removeMax() {
        if (count == 0) {
            return;
        }
        a[1] = a[count];
        --count;
        heapify(a, count, 1);
    }

    //自顶向下
    private void heapify(int [] a, int n, int i) {
        while (true) {
            int maxPos = i;
            //比较左节点
            if (i * 2 <= n && a[i] < a[i * 2]) {
                maxPos = i * 2;
            }
            //比较右节点
            if (i * 2 + 1 <= n && a[maxPos] < a[i * 2 + 1]) {
                maxPos = i * 2 + 1;
            }
            //如果maxPos没变，说明此节点都比子节点大，break
            if (maxPos == i) {
                break;
            }
            swap(a, i, maxPos);
            i = maxPos;
        }
    }

    private void buildHeap(int [] a, int n) {
        //对下标从 n/2 开始到 1 的数据进行堆化，下标是 n/2  +1 到 n 的节点是叶子节点，我们不需要堆化
        for (int i = n / 2; i >= 1; i--) {
            heapify(a, n, i);
        }
    }

    public void sort(int [] a, int n) {
        buildHeap(a, n);
        int k = n;
        while (k > 1) {
            swap(a, 1, k);
            --k;
            heapify(a, k, 1);
        }
    }
}
```



### 优先队列

Java提供了PriorityQueue实现，但是没有实现删除任意元素的方法



## 应用场景

### 优先级队列

在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。相关数据结构和算法：赫夫曼编码、图的最短路径、最小生成树算法等等。

1、合并有序小文件

假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。

解决思路：

1. 整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。
2. 再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。
3. 优化的点：这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。这里就可以用到优先级队列，也可以说是堆。



2、高性能定时器

假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。这样每过 1 秒就扫描一遍任务列表的做法比较低效。

解决思路：

1. 可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。
2. 这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。
3. 当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。



### 利用堆求Top K

Top K问题分为静态和动态。

- 针对静态数据查找前K大数据，可以维护一个大小为K的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较，如果比堆顶元素大，就删除堆顶元素，并将这个元素入堆；如果比堆顶元素小，则继续遍历数组。遍历完数组，堆中的数据就是前K大数据
- 针对动态数据，可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。



### 利用堆求中位数

中位数，顾名思义，就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，那第 n/2+1 个数据就是中位数（注意：假设数据是从 0 开始编号的）；如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 n/2 个和第n/2+1 个数据，这个时候，我们可以随意取一个作为中位数，比如取两个数中靠前的那个，就是第 n/2 个数据。

对于静态数据，直接排序返回下标n/2的元素。

对于动态数据

- 需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。
- 如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。
- 如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。
- 有可能出现，两个堆中的数据个数不符合前面约定的情况,这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。

类似的，应用这个方法，还可以求解“如何快速求接口的 99% 响应时间？”的问题。维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n×99% 个数据，小顶堆中保存 n×1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。



# 九、二分

二分应用特点（局限性）：

- 依赖顺序表结构（数组）
- 数据为有序数据
- 数据量太大或太小也不合适



二分的时间复杂度：O(logN)



二分的实现：

```java

//非递归实现
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {
    int mid = (low + high) / 2;
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return -1;
}

//递归实现
public int bsearch(int [] a, int n, int val){
    return bsearchInternally(a, 0, n - 1,val);
}

private int bsearchInternally(int [] a, int left, int right, int val) {
    if (left > right) {
        return -1;
    }
    int mid = left + ((right - left) >> 1);
    if (a[mid] == val) {
        return mid;
    } else if (a[mid] < val) {
        return bsearchInternally(a, mid + 1, right, val);
    } else {
        return bsearchInternally(a, left, mid - 1, val);
    }
    return -1;
}
```

代码易错细节：

- 循环退出的条件：low <= high；因为若数据的长度为偶数，查找操作的倒数第二步，low会等于high，故比较运算符选择 <= 。 不然，查找操作将被中断。
- mid的取值。mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。
- low和high的更新





## 四种常见的二分查找变形问题

### 变体一：查找第一个值等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {
    int mid = (low + high) / 2;
    if (a[mid] > value) {
        high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
        //等于给定值，有两种情况
        //这个元素是第一个等于给定值的元素
        //不是第一个等于给定值的元素
        //情况一：如果mid=0，即这个元素是数组中的第一个元素，那么一定符合要求；或者a[mid-1]不等于value，也符合要求
        if ((mid == 0) || (a[mid - 1] != value)) {
            return mid;
        } else {
            //情况二：不是等于给定值的第一个元素，那么去左边查找
            high = mid - 1;
        }
    }
  }

  return -1;
}
```

### 变体二：查找最后一个值等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {
    int mid = (low + high) / 2;
    if (a[mid] > value) {
        high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
        //等于给定值，有两种情况
        //这个元素是最后一个等于给定值的元素
        //不是最后一个等于给定值的元素
        //情况一：如果mid=n-1，即这个元素是数组中的最后一个元素，那么一定符合要求；或者a[mid+1]不等于value，也符合要求
        if ((mid == n-1) || (a[mid + 1] != value)) {
            return mid;
        } else {
            //情况二：不是等于给定值的最后一个元素，那么去右边查找
            low = mid + 1;
        }
    }
  }

  return -1;
}
```



### 变体三：查找第一个大于等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {
    int mid = (low + high) / 2;
    if (a[mid] >= value) {
        if ((mid == 0) || (a[mid - 1] < value)) {
            return mid;
        } else {
            low = mid + 1;
        }
    }
  }

  return -1;
}
```

### 变体四：查找最后一个小于等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {
    int mid = (low + high) / 2;
    if (a[mid] <= value) {
        if ((mid == n - 1) || (a[mid + 1] > value)) {
            return mid;
        } else {
            low = mid + 1;
        }
    } else {
        high = mid - 1;
    }
  }

  return -1;
}
```

## 实战

1、变体问题



2、求一个数的平方根，要求精确到小数点后6位

二分查找法 思路：假设是求6的平方根x 

 x 平方根的整数部分 ans是**满足 k^2 ≤ x 的最大k 值**

（1）x=6/2=3

（2）x²=9>6，x继续除以2，1.5²<6，1.5+1.5/2继续 ………… 

（3）直到 |x²-6| 满足条件



3、搜索二维矩阵

先确定行，再二分确定列



4、寻找旋转排序数组中的最小值



5、寻找旋转排序数组中的最小值Ⅱ



## 拓展

### 三分

![image-20220809195758856](数据结构与算法.assets/image-20220809195758856.png)

![image-20220809195813422](数据结构与算法.assets/image-20220809195813422.png)

![image-20220809195821423](数据结构与算法.assets/image-20220809195821423.png)



### 二分答案

![image-20220809195914589](数据结构与算法.assets/image-20220809195914589.png)

![image-20220809195946121](数据结构与算法.assets/image-20220809195946121.png)



### 实战

1、寻找峰值



2、猜数字大小



3、制作m束化所需的最小天数



4、在D天内送达包裹的能力



5、在线选举



6、爱吃香蕉的珂珂





# 十、排序

基于比较的排序算法：通过比较大小来决定元素间的相对次序，可以证明时间复杂度下限为O(logN)

非比较类排序：不通过比较大小来决定元素间的相对次序，时间复杂度受元素的范围以及分布等多种因素影响，不单纯取决于元素规模



比较类：

- 交换排序
  - 冒泡
  - 快排
- 插入排序
  - 简答插入
  - 希尔
- 选择排序
  - 简答选择
  - 堆排
- 归并排序
  - 二路归并
  - 多路归并



非比较：

- 计数排序
- 桶排序
- 基数排序



## 基于比较的各类排序算法

选择排序：每次从未排序数据中找最小值，放到已排序序列的末尾



插入排序：在已排序序列中找到合适的位置进行插入



冒泡排序：循环扫描，每次查看相邻元素，如果逆序，则交换，每一趟可以确定一个元素的位置



堆排序：利用二叉堆选出最值。需要建堆，以及每一次弹出堆顶后的堆化操作



归并排序：基于分治思想，把原问题分解成子问题，最后再合并

```java
public void mergeSort(int [] arr, int left, int right) {
    if (left >= right)
        return;
    int mid = left + ((right - left) >> 1);
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

public void merge(int [] arr, int left, int mid, int right) {
    int [] temp = new int[right - left + 1];
    int index1 = left, index2 = mid + 1, index = 0;
    while (index1 <= mid && index2 <= right) {
        if (arr[index1] <= arr[index2]) {
            temp[index++] = arr[index1++];
        } else {
            temp[index++] = arr[index2++];
        }
    }
    if (index1 <= mid) {
        for (int i = index1; i <= mid; i++) {
            temp[index++] = arr[i];
        }
    }
    if (index2 <= right) {
        for (int i = index2; i <= right; i++) {
            temp[index++] = arr[i];
        }
    }
    for (int i = 0 ; i < temp.length; i++) {
        arr[left + i]  = temp[i];
    }
}
```



快排：也是基于分治的算法。每次从数组中选取基准值pivot，将小元素放到pivot左边，将大元素放到pivot右边，再对左边和右边的子数组递归进行快排。

```java
public void quickSort(int [] arr, int left, int right) {
    if (left >= right)
        return;
    int pivot = partition(arr, left, right);
    quickSort(arr, left, pivot);
    quickSort(arr, pivot + 1, right);
}

public int partition(int [] arr, int left, int right) {
    int pivot = l + (int)(Math.random() * (right - left + 1));
    int pivotVal = arr[pivot];
    while (left < right) {
        while (left < right && arr[right] >= pivotVal)
            right--;
        if (left < right)
            arr[left] = arr[right];
        while (left < right && arr[left] <= pivotVal)
            left++;
        if (left < right)
            arr[right] = arr[left];
    }
    arr[left] = pivotVal;
    return left;
}
```



快排&归排：快排是原地排序，归排需要额外空间O(N)；归排是自底向上的排序，快排是自顶向下的排序









## 非比较类排序算法

非比较类排序算法——桶排序、计数排序、基数排序。也叫线性排序算法，它们的时间复杂度都是线性O(N)。



### 桶排序

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![img](数据结构与算法.assets/987564607b864255f81686829503abae.jpg)

适用性：数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。



场景：有10G的订单数据，需要按订单金额进行排序，内存仅限200MB

解决思路：

- 理想情况下订单金额在1到10万之间均匀分布，那么将订单均匀划分到100个文件中，每个文件存储大约100MB的订单数据，将这100个小文件一次放入内存中排序。等所有文件排序好后，只需要按照文件编号，从小到大一次读取每个小文件的数据，并写入到一个文件中
- 实际订单金额不会是均匀分布，有可能某个区间的数据特别多，划分后的文件会很大，那么针对这些大文件，继续划分小文件。直到所有文件都能读入内存为止



###  计数排序

计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。



何为计数？假设有8个考生，试卷总分是5分，这 8 个考生的成绩放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。

使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的是对应的考生个数。

我们只需要遍历一遍考生分数，就可以得到 C[6]的值。

![img](数据结构与算法.assets/adc75672ef33fa54b023a040834fcbc9.jpg)

从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。

![img](数据结构与算法.assets/361f4d781d2a2d144dcbbbb0b9e6db29.jpg)

我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。

![img](数据结构与算法.assets/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg)

开始进行排序：

从后到前依次扫描数组 A。比如，当扫描到 3 时，从数组 C 中取出下标为 3 的值 7，也就是说，**到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）**。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。

以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了

![img](数据结构与算法.assets/1d730cb17249f8e92ef5cab53ae65784.jpg)

代码实现

```java

// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```



总结：计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

场景：高考查分数系统中的考生省排名。考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将全省考生划分到这 901 个桶里。



### 基数排序

把数据切割成一位位数字，从低位到高位对每一位进行排序（稳定算法）

![img](数据结构与算法.assets/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg)



基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。

场景：对10万个手机号码排序；排序牛津字典



## 实战

1、排序数组



2、数组的相对排序



3、合并区间



4、数组中的第K个最大元素



5、货仓选址



6、翻转对



7、区间和个数

