# 缓存基础

## 相关面试题

- 为什么要使用缓存
- 本地缓存应该怎么做
- 为什么要有分布式缓存/为什么不直接使用本地缓存
- 多级缓存
- 常见的缓存读写模式/更新策略



## 缓存的基本思想

本质：空间换时间！

应用：

- CPU cache：用于解决CPU处理速度和内存不匹配的问题
- 内存缓存：解决硬盘访问速度过慢问题
- 页表方案：引入快表加速虚拟地址到物理地址的转换
- 业务系统：避免用户在请求数据时获取速度过于缓慢



## 使用缓存带来的问题

- 系统复杂性增加：需要维护缓存与数据库的一致性，维护热点缓存
- 系统开发成本增加：增加一个单独的缓存服务



## 本地缓存

适用场景：单体架构，数据量不大，没并且有分布式要求

![image-20220423111720850](../../../AppData/Roaming/Typora/typora-user-images/image-20220423111720850.png)

#### 本地缓存的方案

一个稍微完善的缓存框架至少要提供：**过期时间、淘汰机制、命中率统计**

1. JDK自带的HashMap和ConcurrentHashMap
   两者都是存放key/value键值对。但大部分场景不会适用两者当作缓存，因为只提供了缓存功能，并没有提供其他诸如过期时间的功能。
2. Ehcache、Guava Cache、Spring Cache，使用较多
   ![image-20220423112255094](../../../AppData/Roaming/Typora/typora-user-images/image-20220423112255094.png)
3. Caffeine



#### 优点&缺点

低依赖、轻量、简单、成本低

多个相同服务之间的本地缓存数据无法共享，对分布式架构不友好；容量受服务部署所在的机器限制



## 分布式缓存

分布式缓存看作一种内存数据库服务

![image-20220423113353917](../../../AppData/Roaming/Typora/typora-user-images/image-20220423113353917.png)

缺点：需要引入额外的服务如redis、memcached，需要保证服务的高可用



## 多级缓存

本地缓存+分布式缓存

方案：L1使用本地内存（Caffeine），L2使用分布式缓存（redis）。读取缓存数据时，先从L1中读取，读取不到再去L2读取，这样可以降低L2的压力，减少L2的读次数。



J2Cache



## 缓存读写模式/更新策略

### Cahce Aside Pattern 旁路缓存模式

适合读请求比较多的场景

CAP中服务端需要同时维系DB和cache，并且以DB结果为准

写策略：先更新DB，再直接删除cache

![image-20220423114405717](../../../AppData/Roaming/Typora/typora-user-images/image-20220423114405717.png)

读策略：从cache中读数据，读到直接返回；cache中读取不到，就从DB中读取数据返回；再把数据放到cache中

![image-20220423114446032](../../../AppData/Roaming/Typora/typora-user-images/image-20220423114446032.png)

![image-20220423114925889](../../../AppData/Roaming/Typora/typora-user-images/image-20220423114925889.png)

缺陷：

1. 首次请求的数据一定不在cache中。解决：将热点数据提前放入cache
2. 写操作比较频繁会导致cache数据频繁删除，导致命中率降低
   1. 数据库和缓存强一致场景：更新DB的同时更新cache，不过需要加一个锁/分布式锁保证更新cache不存在线程安全问题
   2. 可以短暂地允许数据库和缓存数据不一致场景：更新DB的同时更新cache，但是给缓存加一个比较短的过期时间





### Read/Write Through Pattern 读写穿透

在此策略中，服务端把cache视为主要数据存储，从中读取数据并将数据写入其中。cache服务负责数据读取和写入DB



写策略：先查cache，cache中不存在，直接更新DB；cache中存在，则先更新cache，然后cache服务自己更新DB

![image-20220423143110818](../../../AppData/Roaming/Typora/typora-user-images/image-20220423143110818.png)

读策略：从cache中读，读到就直接返回；读取不到，先从DB加载，写到cache后返回

![image-20220423143224882](../../../AppData/Roaming/Typora/typora-user-images/image-20220423143224882.png)



### Write Behind Pattern 异步缓存写入

与上一个模式相似，两者都是由cache服务来负责cache和DB的读写。不同点在于：上一个模式时同步更新cache和DB，而此模式则是只更新缓存，不直接更新DB，而是改为异步批量的方式来更新DB



应用场景：消息队列中消息的异步写入磁盘、MySQL的InnoDB Buffer Pool机制等

适合一些数据经常变化而又对数据一致性要求没那么搞得场景，如浏览量、点赞量等